# 常见算法

## 分治算法(Hanoitower.java)

> 分治算法是一种很重要的算法，它可以将一个大问题分解为若干小问题，然后递归地求解小问题，最后将结果合并为大问题的解。
>
> 如排序算法（快速排序，归并排序），傅里叶交换（快速傅里叶变换）······

1. 分治算法可以求解的一些问题：
    1. 二分搜索
    2. 大整数乘法
    3. 棋盘覆盖
    4. 合并排序
    5. 快速排序
    6. 线性时间选择
    7. 最接近点对问题
    8. 循环赛日程表
    9. 汉若塔
2. 分治算法的基本步骤
    1. 分解：将原问题分解为若干个规模小，相互独立，与原问题形式相同的子问题
    2. 解决：若子问题规模较小而容易则自己解，否则递归地解决各个子问题
    3. 合并：将各个子问题的解合并为原问题的解

## 动态规划算法(KnapsackProblem.java)

> 动态规划算法的核心是：将大的问题划分为小问题进行解决，从而一步步获取最优解的处理算法
>
> 动态规划算法与分治算法类似，与分治算法不同的是，动态规划求解的问题是，经分解得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上的）

1. 背包问题
    1. 是指给定一个给定一个容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。
    2. 其中又分为01背包和完全背包（每种物品可以无限件使用）
    3. 这里的01背包指的是每个物品最多放一个，而无限背包可以转化为01背包
2. 思路分析
    1. 每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中，即对于给定的n个物品，设w[i]和v[i]分别为第 i 个物品的价值和重量，C为背包的容量，再令v[i][j]
       表示在前i个物品中能够装入容量为j的背包中的最大价值
    2. 结果如下
        1. 公式中的i和j均从0开始
        2. v[i][0]=v[0][j]=0
        3. 当w[i]>j时;v[i][j]=v[i-1][j] //当准备加入的新增的商品的容量大于当前背包的容量时，直接使用上一个但云哥的转入策略
        4. 当j>=w[i]时：v[i][j]=max{v[i-1][j] , v[i]+v[i-1][j-w[i]]}
3. 例子(对应KnapsackProblem.java)
    1. | 物品    | 重量 | 价格 |
                                                    | ------- | ---- | ---- |
       | 吉他(G) | 1    | 1500 |
       | 音响(S) | 4    | 3000 |
       | 电脑(L) | 2    | 2000 |

## KMP算法

> 应用场景-字符串匹配
>
> 实现：暴力匹配法、KMP算法

### 暴力匹配算法(ViolenceMatch.java)

思路分析

1. 假设现在str1匹配到i位置，子串str2匹配到j位置，则有
2. 如果当前字符匹配成功（str1[i]==str2[j]），则i++，j++,继续下一个字符
3. 如果匹配不成功，令 i = i -(j-1),j=0.相当与每次匹配失败就i回溯，j回到0
4. 问题：每次匹配失败就回溯，浪费大量的时间

### KMP算法(KMPAlgorithm.java)

> KMP是解决模式串在文本串是否出现过，如果出现过，返回最早出现的位置
>
> KMP算法就是利用之前判断过的信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去大量的计算时间 思路分析

1. 部分匹配值就是前缀和后缀的最长的共有元素的长度

## 贪心算法(GreedyAlgorithm.java)

> 应用场景-集合覆盖问题
>
> 贪心算法（贪婪算法）是指在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
>
> 贪心算法得到的结果不一定是最优解，但总能够快速找到一个满意的解。

应用

- 假设存在如下表的需要付费的广播台，以及信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号

  | 广播台 | 覆盖地区         |
              | ------ | ---------------- |
  | k1     | 北京、上海、天津 |
  | k2     | 广州、北京、深圳 |
  | k3     | 成都、北京、杭州 |
  | k4     | 上海、天津       |
  | k5     | 杭州、大连       |
- 思路分析
    - 可以使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集，使用时间较长，如有n个广播台，那么组合为2^n种
    - 使用贪心算法，效率更高
        - ①遍历所有的广播台，找到一个覆盖最多**未覆盖的地区**的电台（此电台可能包含一些已覆盖的地区，但没有关系）
        - ②将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去掉
        - ③重复第一步知道覆盖了全部的地区

## 普利姆算法Prim(PrimAlgorithm.java)

> 普丽姆算法是求最小生成树的算法，它的基本思想是：在包含n个顶点的连通图中，找出只有（n-1）条边包含所有顶点的连通子图，也就是所谓的极小连通图
>
> 图详见img.png

### 应用

- 修路问题本质就是**最小生成树**，求最小生成树的路径长度，简称MST
    - 给定一个带权的无向图，如何选取一棵生成树，使得生成树的路径长度最小
    - N个顶点，一定有N-1条边
    - 包含全部顶点
    - 求最小生成树的算法主要有普丽姆算法Prim和Kruskal算法

### 普利姆算法Prim

- 设G=(V,E)是连通图，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边集合
- 若从顶点u开始构造最小生成树，则从集合v中取出顶点u放入集合U中，标记顶点v的visited[u]=1;
  -若集合U中顶点ui与集合V-U中的顶点vj之间存在边（也就是已经相连的顶点构成的整体），则寻找这些边中权值最小的边，但不能构成回路（否则找次小）将顶点vj加入到集合U中，将边（ui,vj）加入到集合D中，标记顶点vj的visited[vj]
  =1;
- 重复以上步骤，直到集合V-U中所有顶点都被加入到集合U中，即所有的顶点被访问过，此时集合U中的顶点就是最小生成树的顶点

## 克鲁斯卡尔算法Kruskal()

> Kruskal算法是求最小生成树的算法，它的基本思想是：在包含n个顶点的连通图中，找出只有（n-1）条边包含所有顶点的连通子图，也就是所谓的极小连通图
>
> 图详见img_1.png

### 应用

公交站问题

- 某城市新增7个站点（A,B,C,D,E,F,G）现在需要修路把这7个站点连接起来，求最小的路程
- 各个站点的距离用边线权值表示

### 克鲁斯卡尔算法Kruskal

- 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不能构成回路
- 具体做法：首先构造一个n个顶点的森林，然后依次将权值最小的边加入到森林中，直到森林中的顶点数量为n-1，并不能构成回路
- 主要问题
    - 问题一对图的所有边进行排序，按照权值从小到大的顺序
        - 解决：使用排序算法排序
    - 问题二：如何判断是否形成回路
        - 解决：记录顶点在最小生成树中的终点，顶点的终点是在最小生成树中与它连通的最大顶点。然后每次需要将一条边添加到最小生成树时，判断该边的两个顶点的终点是否重复，如果重复则不添加
        - 也就是相同终点的顶点相连构成回路

## 迪杰斯特拉算法Dijkstra(DijkstraAlgorithm.java)

> 迪杰斯特拉算法是求最短路径的算法，用于计算一个结点到另一个结点的最短路径，最主要的特点是以起始点为中心向外层扩展，直到扩展到终点为止
>
> 详见img.png

### 应用

最短路径问题

- 胜利乡有7个村庄，现在有6个邮差，每个邮差都要去一个村庄，求最短路径

### 迪杰斯特拉算法Dijkstra

算法过程

- 设置出发点为顶点v，顶点集合V{v1,v2,v3,v4,v5,v6,v7······} v到V中各顶点的距离构成距离集合Dis，Dis集合记录着v到图中各顶点的距离
    - 从Dis中找出最小的距离，记为d，将d所在的顶点加入到集合V中
    - 更新Dis集合，将d顶点的距离更新为d到其他顶点的距离，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的那个
    - 重复执行以上两个步骤，直到最短路径顶点为目标顶点即可结束

## 弗洛伊德算法Floyd()

## 骑士周游回溯算法()
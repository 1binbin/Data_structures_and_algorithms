# 常见算法

## 分治算法(Hanoitower.java)

> 分治算法是一种很重要的算法，它可以将一个大问题分解为若干小问题，然后递归地求解小问题，最后将结果合并为大问题的解。
>
> 如排序算法（快速排序，归并排序），傅里叶交换（快速傅里叶变换）······

1. 分治算法可以求解的一些问题：
   1. 二分搜索
   2. 大整数乘法
   3. 棋盘覆盖
   4. 合并排序
   5. 快速排序
   6. 线性时间选择
   7. 最接近点对问题
   8. 循环赛日程表
   9. 汉若塔
2. 分治算法的基本步骤
   1. 分解：将原问题分解为若干个规模小，相互独立，与原问题形式相同的子问题
   2. 解决：若子问题规模较小而容易则自己解，否则递归地解决各个子问题
   3. 合并：将各个子问题的解合并为原问题的解

## 动态规划算法(KnapsackProblem.java)

> 动态规划算法的核心是：将大的问题划分为小问题进行解决，从而一步步获取最优解的处理算法
>
> 动态规划算法与分治算法类似，与分治算法不同的是，动态规划求解的问题是，经分解得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上的）

1. 背包问题
   1. 是指给定一个给定一个容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。
   2. 其中又分为01背包和完全背包（每种物品可以无限件使用）
   3. 这里的01背包指的是每个物品最多放一个，而无限背包可以转化为01背包
2. 思路分析
   1. 每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中，即对于给定的n个物品，设w[i]和v[i]分别为第 i 个物品的价值和重量，C为背包的容量，再令v[i][j]
      表示在前i个物品中能够装入容量为j的背包中的最大价值
   2. 结果如下
      1. 公式中的i和j均从0开始
      2. v[i][0]=v[0][j]=0
      3. 当w[i]>j时;v[i][j]=v[i-1][j] //当准备加入的新增的商品的容量大于当前背包的容量时，直接使用上一个但云哥的转入策略
      4. 当j>=w[i]时：v[i][j]=max{v[i-1][j] , v[i]+v[i-1][j-w[i]]}
3. 例子(对应KnapsackProblem.java)
   1. | 物品    | 重量 | 价格 |
                        | ------- | ---- | ---- |
      | 吉他(G) | 1    | 1500 |
      | 音响(S) | 4    | 3000 |
      | 电脑(L) | 2    | 2000 |

## KMP算法

> 应用场景-字符串匹配
>
> 实现：暴力匹配法、KMP算法

### 暴力匹配算法(ViolenceMatch.java)

思路分析

1. 假设现在str1匹配到i位置，子串str2匹配到j位置，则有
2. 如果当前字符匹配成功（str1[i]==str2[j]），则i++，j++,继续下一个字符
3. 如果匹配不成功，令 i = i -(j-1),j=0.相当与每次匹配失败就i回溯，j回到0
4. 问题：每次匹配失败就回溯，浪费大量的时间

### KMP算法(KMPAlgorithm.java)

> KMP是解决模式串在文本串是否出现过，如果出现过，返回最早出现的位置
>
> KMP算法就是利用之前判断过的信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去大量的计算时间 思路分析

1. 部分匹配值就是前缀和后缀的最长的共有元素的长度

## 贪心算法(GreedyAlgorithm.java)

> 应用场景-集合覆盖问题
>
> 贪心算法（贪婪算法）是指在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
>
> 贪心算法得到的结果不一定是最优解，但总能够快速找到一个满意的解。

应用

- 假设存在如下表的需要付费的广播台，以及信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号

  | 广播台 | 覆盖地区         |
    | ------ | ---------------- |
  | k1     | 北京、上海、天津 |
  | k2     | 广州、北京、深圳 |
  | k3     | 成都、北京、杭州 |
  | k4     | 上海、天津       |
  | k5     | 杭州、大连       |
- 思路分析
    - 可以使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集，使用时间较长，如有n个广播台，那么组合为2^n种
    - 使用贪心算法，效率更高
        - ①遍历所有的广播台，找到一个覆盖最多**未覆盖的地区**的电台（此电台可能包含一些已覆盖的地区，但没有关系）
        - ②将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去掉
        - ③重复第一步知道覆盖了全部的地区

## 普丽姆算法Prim()

## 克鲁斯卡尔算法Kruskal()

## 迪杰斯特拉算法Dijkstra()

## 弗洛伊德算法Floyd()

## 骑士周游回溯算法()
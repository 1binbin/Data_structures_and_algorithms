# 排序算法
> 排序是将一组数据，依照指定的顺序进行排列的过程
> 
> 算法可视化工具 https://visualgo.net/zh
## 排序分类
1. 外部排序
    1. 指的是将一组数据都加载到内部存储器中进行排序
2. 内部排序
    1. 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
3. 常见的排序算法（均属于内部排序）8种
    1. 插入排序--**直接插入排序、希尔排序**
    2. 选择排序--**简单选择排序、堆排序**
    3. 交换排序--**冒泡排序、快速排序**
    4. **归并排序**
    5. **基数排序**

## 时间复杂度
### 时间频度
- 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)
### 时间复杂度
- 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))为算法的时间复杂度
- 计算时间复杂度的方法
  - 用常数1代替运行时间中的所有加法常数 T(n) = n^2 + 7n + 6  => T(n) = n^2 + 7n +1
  - 修改后的运行次数函数中，只保留最高阶级 T(n) = n^2 + 7n +1 => T(n) = n^2
  - 去除最高阶项的系数 T(n) = n^2 => T(n) = n^2 = O(n^2)
- 时间复杂度从小到大排序为 **常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < k次方阶 < 指数阶**
### 平均时间复杂度和最坏时间复杂度
> **平均时间复杂度**是指所有可能的输入实例均以等概率出现的情况下，该算法下的运行时间
> 
> **最坏时间复杂度**是在最坏的情况下的运行时间，一般考虑最坏时间复杂度

| 排序算法 | 平均时间 | 最差情形     | 稳定度 | 额外空间 | 备注                         |
| -------- | -------- | ------------ | ------ | -------- | ---------------------------- |
| 冒泡     | O(n^2)   | O(n^2)       | 稳定   | O(1)     | n小时较好                    |
| 交换     | O(n^2)   | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 选择     | O(n^2)   | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 插入     | O(n^2)   | O(n^2)       | 稳定   | O(1)     | 大部分已排序时较好           |
| 基数     | O(logRB) | O(logRB)     | 稳定   | O(n)     | B是真数(0-9) R是基数(个十百) |
| Shell    | O(nlogn) | O(n^s) 1<s<2 | 不稳定 | O(1)     | s是所选分组                  |
| 快速     | O(nlogn) | O(n^2)       | 不稳定 | O(nlogn) | n大时较好                    |
| 归并     | O(nlogn) | O(nlogn)     | 稳定   | O(1)     | n大时较好                    |
| 堆       | O(nlogn) | O(nlogn)     | 不稳定 | O(1)     | n大时较好                    |

## 冒泡排序(BubbleSort.java)
> 基本思路：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较**相邻元素**的值，若发现**逆序**则交换，使值较大的元素逐渐从前移向后部，使值大的元素逐渐从前移向后部
> 
规则
1. 一共进行 数组的大小 -1 次循环
2. 每一趟排序的次数在逐渐减少
3. **优化**：如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，因为已经是有序的
## 选择排序(SelectSort.java)
> 选择排序也是内部排序，是从欲排序的数据中，按指定的规则选出某一元素，再依次规定交换达到排序的目的
> 
> 基本思想：第一次从arr[0]到arr[n-1]中选择最小值，与arr[0]交换，第二次从arr[1]到arr[n-1]找到最小值，与arr[1]交换，以此类推
> 
说明：
1. 选择排序一共有 数组大小 -1 次排序
2. 每一轮排序，又是一个循环，循环的规则
   1. 先假定当前的这个数是最小值
   2. 然后和后面的每个数进行比较，如果发现有更小的数
   3. 重新最小值，并确定下标，当遍历到数组最后时，就得到本轮最小数和下标
   4. 将最小值交换为第一个元素
### 插入排序(InsertSort.java)
> 基本思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它按照顺序插入到有序表中的适当位置
>
存在问题：
1. 当需要插入的数是较小的数，后移的次数明显增多，对效率影响较大
### 希尔排序(ShellSort.java)
> 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序
> 
> 基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越富哦，当增量降至1时，整个文件恰好分成一组，算法即便终止


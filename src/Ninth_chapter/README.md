# 排序算法
> 排序是将一组数据，依照指定的顺序进行排列的过程
> 
> 算法可视化工具 https://visualgo.net/zh
## 排序分类
1. 外部排序
    1. 指的是将一组数据都加载到内部存储器中进行排序
2. 内部排序
    1. 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
3. 常见的排序算法（均属于内部排序）8种
    1. 插入排序--**直接插入排序、希尔排序**
    2. 选择排序--**简单选择排序、堆排序**
    3. 交换排序--**冒泡排序、快速排序**
    4. **归并排序**
    5. **基数排序**

## 时间复杂度
### 时间频度
- 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)
### 时间复杂度
- 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))为算法的时间复杂度
- 计算时间复杂度的方法
  - 用常数1代替运行时间中的所有加法常数 T(n) = n^2 + 7n + 6  => T(n) = n^2 + 7n +1
  - 修改后的运行次数函数中，只保留最高阶级 T(n) = n^2 + 7n +1 => T(n) = n^2
  - 去除最高阶项的系数 T(n) = n^2 => T(n) = n^2 = O(n^2)
- 时间复杂度从小到大排序为 **常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < k次方阶 < 指数阶**
### 平均时间复杂度和最坏时间复杂度
> **平均时间复杂度**是指所有可能的输入实例均以等概率出现的情况下，该算法下的运行时间
> 
> **最坏时间复杂度**是在最坏的情况下的运行时间，一般考虑最坏时间复杂度

| 排序算法 | 平均时间 | 最差情形     | 稳定度 | 额外空间 | 备注                         |
| -------- | -------- | ------------ | ------ | -------- | ---------------------------- |
| 冒泡     | O(n^2)   | O(n^2)       | 稳定   | O(1)     | n小时较好                    |
| 交换     | O(n^2)   | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 选择     | O(n^2)   | O(n^2)       | 不稳定 | O(1)     | n小时较好                    |
| 插入     | O(n^2)   | O(n^2)       | 稳定   | O(1)     | 大部分已排序时较好           |
| 基数     | O(logRB) | O(logRB)     | 稳定   | O(n)     | B是真数(0-9) R是基数(个十百) |
| Shell    | O(nlogn) | O(n^s) 1<s<2 | 不稳定 | O(1)     | s是所选分组                  |
| 快速     | O(nlogn) | O(n^2)       | 不稳定 | O(nlogn) | n大时较好                    |
| 归并     | O(nlogn) | O(nlogn)     | 稳定   | O(1)     | n大时较好                    |
| 堆       | O(nlogn) | O(nlogn)     | 不稳定 | O(1)     | n大时较好                    |

## 冒泡排序
> 基本思路：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较**相邻元素**的值，若发现**逆序**则交换，使值较大的元素逐渐从前移向后部，使值大的元素逐渐从前移向后部
> 
规则
1. 一共进行 数组的大小 -1 次循环
2. 每一趟排序的次数在逐渐减少
3. **优化**：如果发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序，因为已经是有序的